---
title: "STAT 545B Assignment B-1"
output: github_document
author: "Sarah Masri"
date: "2023-10-29"
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

## Load Packages

```{r, message = FALSE}
suppressPackageStartupMessages(library(tidyverse))
suppressPackageStartupMessages(library(rigr) )
suppressPackageStartupMessages(library(testthat))
```


## Exercise 1: Make a Function (25 points)
In this assignment, I will be making a function and fortifying it. The function's purpose is to summarize the count of specific groups in a given dataset. One might be interested in the number of classes with in a single field, as well as the number of classes at the intersection of several fields. 


## Exercise 2: Document your Function (20 points)

The following code chunk includes the function proposed in Exercise 1, as well as relevant roxygen2 tags.

```{r}

#' @title Count Groups
#' @description This function provides the counts of entries belonging to classes in a variable or variables of a dataset.
#' @param df A dataframe with at least 1 column and 1 row.
#' @param groupby_cols A string or list of strings specifying the column name(s) that the function will use to group the data. Must have length at least 1. 
#' @return A tibble which summaries the count of entries within each group or combination of groups (if the data is grouped by more than 1 column). 
count_groups <- function(df, groupby_cols) {
  df_cols <- colnames(df)
  
  ## Check that df has at least one row and one column
  if(nrow(df) == 0 | ncol(df) == 0) {stop("Dataframe must have at least one non-empty entry.")}
  
  ## Check that groupby_cols is non empty
  if (length(groupby_cols) == 0) {stop("groupby_cols is empty. Please provide at least one column name.")}
  
  ## Check that groupby_cols is a single string or list of string
  if (class(groupby_cols) != "character") {stop("At least one variable in groupby_cols is not a string.")}
  
  ## Check that each string in groupby_cols are valid column names
  if(!all(groupby_cols %in% df_cols)) {stop("The following strings provided are not valid column names: ", toString(groupby_cols[which(!groupby_cols %in% df_cols)]))}

  count_tbl <- df %>% group_by_at(groupby_cols) %>%  summarize(n = n())
  count_tbl
}
```


## Exercise 3: Include examples (15 points)
Demonstrate the usage of your function with a few examples. 

We use the `fev` dataset in the `rigr` package. Before showing a few examples of `count_groups`, a preview of the data is shown below.

```{r}
head(fev)
```

The following example summarises the number of smokers vs. non-smokers. One may expect two rows (`smoke` and `n` for count) and two columns (for smokers and non-smokers).

```{r}
count_groups(fev, "smoke")
```
The next example groups by two columns in the dataset: sex and smoking status. Since each variable has two classes (female/male and no/yes respectively), then one may expect $2^2 = 4$ rows and three rows (`sex`, `smoke`, and `n` for count).

```{r}
count_groups(fev, c("sex", "smoke"))
```

The last working example groups by three columns in the dataset: sex, smoking status, and age. This example shows that as the number of variables used to group the data increases, so does the number of rows. This summary table is particularly large since the age variables ranges from 3 to 19. Although it may not be particularly helpful for this function to be used with nmany variables with a large number of classes each, the function still works and maintains its general functionality. 


```{r}
count_groups(fev, c("sex", "smoke", "age"))
```
The final examples are cases where an error is expected. This is due to the fact that "smoker" and "age_group" are not valid column names in the `fev` dataset. 

```{r, error = TRUE}
count_groups(fev, c("sex", "smoker", "age"))

count_groups(fev, c("sex", "smoker", "age_group"))
```

## Exercise 4: Test the Function (25 points)

We write formal tests for the `count_groups` function with at least three non-redundant uses of an `expect_()` function from the `testthat` package, contained in a `test_that()` function (or more than one). They should all pass.


#### Test 1: 
Check that invalid (empty) dataframes will throw an error. 

```{r}
test_that("Invalid dataframe", expect_error(count_groups(data.frame(), "column1")))
```
#### Test 2: 
groupby_names that are not valid column names **and** a string will throw an error. 
```{r}
test_that("Invalid groupby_names", {
  expect_error(count_groups(fev, c()))                    ## empty list not valid
  expect_error(count_groups(fev, "column1"))              ## 'column1' is not a valid colname
  expect_error(count_groups(fev, c("sex", "smoking")))    ## 'smoking' is not a valid colname, but 'sex' is
  expect_error(count_groups(fev, c(1, 2)))                ## groupby_names are not strings
          })
                                                                                                      
```
#### Test 3:
Check expected dimensions of summary tables. Number of rows should be the number of combinations of classes between variables provided. If the number of variables in groupby_names is k, then the expected number of columns is k+1. 
```{r}
test_that("Summary tables have correct dimensions", {
  expect_equal(dim(count_groups(fev, c("sex"))), c(2, 2))
  expect_equal(dim(count_groups(fev, c("sex", "smoke"))), c(4, 3))
  })
```

#### Test 4: 
For a set of groupby_names, the information given by count_groups should be equivalent regardless of the order in groupby_names. 
```{r}
test_that("Order of group-by variables does not matter", {
  expect_equal(sort(count_groups(fev, c("sex", "smoke"))$n), sort(count_groups(fev, c("smoke", "sex"))$n))
  expect_equal(sort(count_groups(fev, c("sex", "smoke", "age"))$n), sort(count_groups(fev, c("age", "smoke", "sex"))$n))
  })
                                                                                                          
```
